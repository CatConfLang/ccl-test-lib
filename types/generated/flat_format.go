// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package generated

import "encoding/json"
import "fmt"
import "reflect"

// Schema for existing generated flat test files (*-flat.json)
type GeneratedFormatJson []struct {
	// Optional arguments for parameterized functions
	Args []string `json:"args,omitempty" yaml:"args,omitempty" mapstructure:"args,omitempty"`

	// Implementation behavior choices
	Behaviors []GeneratedFormatJsonElemBehaviorsElem `json:"behaviors" yaml:"behaviors" mapstructure:"behaviors"`

	// Mutually exclusive options by category
	Conflicts *GeneratedFormatJsonElemConflicts `json:"conflicts,omitempty" yaml:"conflicts,omitempty" mapstructure:"conflicts,omitempty"`

	// Expected error type for error tests
	ErrorType *string `json:"error_type,omitempty" yaml:"error_type,omitempty" mapstructure:"error_type,omitempty"`

	// Whether this test should produce an error
	ExpectError bool `json:"expect_error,omitempty" yaml:"expect_error,omitempty" mapstructure:"expect_error,omitempty"`

	// Expected result in standardized format
	Expected GeneratedFormatJsonElemExpected `json:"expected" yaml:"expected" mapstructure:"expected"`

	// Required language features
	Features []GeneratedFormatJsonElemFeaturesElem `json:"features" yaml:"features" mapstructure:"features"`

	// CCL functions tested by this test
	Functions []GeneratedFormatJsonElemFunctionsElem `json:"functions,omitempty" yaml:"functions,omitempty" mapstructure:"functions,omitempty"`

	// CCL input text to be tested
	Input string `json:"input" yaml:"input" mapstructure:"input"`

	// CCL implementation level (1-5)
	Level *int `json:"level,omitempty" yaml:"level,omitempty" mapstructure:"level,omitempty"`

	// Unique test name (source_name + validation function)
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Functions that must be implemented as prerequisites
	Requires []string `json:"requires,omitempty" yaml:"requires,omitempty" mapstructure:"requires,omitempty"`

	// Original source test name for traceability
	SourceTest *string `json:"source_test,omitempty" yaml:"source_test,omitempty" mapstructure:"source_test,omitempty"`

	// Single CCL function to validate
	Validation GeneratedFormatJsonElemValidation `json:"validation" yaml:"validation" mapstructure:"validation"`

	// Specification variants
	Variants []GeneratedFormatJsonElemVariantsElem `json:"variants" yaml:"variants" mapstructure:"variants"`
}

type GeneratedFormatJsonElemBehaviorsElem string

const GeneratedFormatJsonElemBehaviorsElemBooleanLenient GeneratedFormatJsonElemBehaviorsElem = "boolean_lenient"
const GeneratedFormatJsonElemBehaviorsElemBooleanStrict GeneratedFormatJsonElemBehaviorsElem = "boolean_strict"
const GeneratedFormatJsonElemBehaviorsElemCrlfNormalizeToLf GeneratedFormatJsonElemBehaviorsElem = "crlf_normalize_to_lf"
const GeneratedFormatJsonElemBehaviorsElemCrlfPreserveLiteral GeneratedFormatJsonElemBehaviorsElem = "crlf_preserve_literal"
const GeneratedFormatJsonElemBehaviorsElemListCoercionDisabled GeneratedFormatJsonElemBehaviorsElem = "list_coercion_disabled"
const GeneratedFormatJsonElemBehaviorsElemListCoercionEnabled GeneratedFormatJsonElemBehaviorsElem = "list_coercion_enabled"
const GeneratedFormatJsonElemBehaviorsElemLooseSpacing GeneratedFormatJsonElemBehaviorsElem = "loose_spacing"
const GeneratedFormatJsonElemBehaviorsElemStrictSpacing GeneratedFormatJsonElemBehaviorsElem = "strict_spacing"
const GeneratedFormatJsonElemBehaviorsElemTabsPreserve GeneratedFormatJsonElemBehaviorsElem = "tabs_preserve"
const GeneratedFormatJsonElemBehaviorsElemTabsToSpaces GeneratedFormatJsonElemBehaviorsElem = "tabs_to_spaces"

var enumValues_GeneratedFormatJsonElemBehaviorsElem = []interface{}{
	"boolean_strict",
	"boolean_lenient",
	"crlf_preserve_literal",
	"crlf_normalize_to_lf",
	"tabs_preserve",
	"tabs_to_spaces",
	"strict_spacing",
	"loose_spacing",
	"list_coercion_enabled",
	"list_coercion_disabled",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GeneratedFormatJsonElemBehaviorsElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GeneratedFormatJsonElemBehaviorsElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GeneratedFormatJsonElemBehaviorsElem, v)
	}
	*j = GeneratedFormatJsonElemBehaviorsElem(v)
	return nil
}

// Mutually exclusive options by category
type GeneratedFormatJsonElemConflicts struct {
	// Behaviors corresponds to the JSON schema field "behaviors".
	Behaviors []string `json:"behaviors,omitempty" yaml:"behaviors,omitempty" mapstructure:"behaviors,omitempty"`

	// Features corresponds to the JSON schema field "features".
	Features []string `json:"features,omitempty" yaml:"features,omitempty" mapstructure:"features,omitempty"`

	// Functions corresponds to the JSON schema field "functions".
	Functions []string `json:"functions,omitempty" yaml:"functions,omitempty" mapstructure:"functions,omitempty"`

	// Variants corresponds to the JSON schema field "variants".
	Variants []string `json:"variants,omitempty" yaml:"variants,omitempty" mapstructure:"variants,omitempty"`
}

// Expected result in standardized format
type GeneratedFormatJsonElemExpected struct {
	// Number of expected results/assertions
	Count int `json:"count" yaml:"count" mapstructure:"count"`

	// Expected entries for parse functions
	Entries []GeneratedFormatJsonElemExpectedEntriesElem `json:"entries,omitempty" yaml:"entries,omitempty" mapstructure:"entries,omitempty"`

	// Whether this should produce an error
	Error bool `json:"error,omitempty" yaml:"error,omitempty" mapstructure:"error,omitempty"`

	// Expected list for list access functions
	List []interface{} `json:"list,omitempty" yaml:"list,omitempty" mapstructure:"list,omitempty"`

	// Expected object for hierarchy functions
	Object interface{} `json:"object,omitempty" yaml:"object,omitempty" mapstructure:"object,omitempty"`

	// Expected single value for typed access functions
	Value interface{} `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`
}

type GeneratedFormatJsonElemExpectedEntriesElem struct {
	// Key corresponds to the JSON schema field "key".
	Key string `json:"key" yaml:"key" mapstructure:"key"`

	// Value corresponds to the JSON schema field "value".
	Value string `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GeneratedFormatJsonElemExpectedEntriesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["key"]; raw != nil && !ok {
		return fmt.Errorf("field key in GeneratedFormatJsonElemExpectedEntriesElem: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in GeneratedFormatJsonElemExpectedEntriesElem: required")
	}
	type Plain GeneratedFormatJsonElemExpectedEntriesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GeneratedFormatJsonElemExpectedEntriesElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GeneratedFormatJsonElemExpected) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["count"]; raw != nil && !ok {
		return fmt.Errorf("field count in GeneratedFormatJsonElemExpected: required")
	}
	type Plain GeneratedFormatJsonElemExpected
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["error"]; !ok || v == nil {
		plain.Error = false
	}
	*j = GeneratedFormatJsonElemExpected(plain)
	return nil
}

type GeneratedFormatJsonElemFeaturesElem string

const GeneratedFormatJsonElemFeaturesElemComments GeneratedFormatJsonElemFeaturesElem = "comments"
const GeneratedFormatJsonElemFeaturesElemEmptyKeys GeneratedFormatJsonElemFeaturesElem = "empty_keys"
const GeneratedFormatJsonElemFeaturesElemExperimentalDottedKeys GeneratedFormatJsonElemFeaturesElem = "experimental_dotted_keys"
const GeneratedFormatJsonElemFeaturesElemMultiline GeneratedFormatJsonElemFeaturesElem = "multiline"
const GeneratedFormatJsonElemFeaturesElemUnicode GeneratedFormatJsonElemFeaturesElem = "unicode"
const GeneratedFormatJsonElemFeaturesElemWhitespace GeneratedFormatJsonElemFeaturesElem = "whitespace"

var enumValues_GeneratedFormatJsonElemFeaturesElem = []interface{}{
	"comments",
	"empty_keys",
	"experimental_dotted_keys",
	"multiline",
	"unicode",
	"whitespace",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GeneratedFormatJsonElemFeaturesElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GeneratedFormatJsonElemFeaturesElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GeneratedFormatJsonElemFeaturesElem, v)
	}
	*j = GeneratedFormatJsonElemFeaturesElem(v)
	return nil
}

type GeneratedFormatJsonElemFunctionsElem string

const GeneratedFormatJsonElemFunctionsElemAssociativity GeneratedFormatJsonElemFunctionsElem = "associativity"
const GeneratedFormatJsonElemFunctionsElemBuildHierarchy GeneratedFormatJsonElemFunctionsElem = "build_hierarchy"
const GeneratedFormatJsonElemFunctionsElemCanonicalFormat GeneratedFormatJsonElemFunctionsElem = "canonical_format"
const GeneratedFormatJsonElemFunctionsElemCompose GeneratedFormatJsonElemFunctionsElem = "compose"
const GeneratedFormatJsonElemFunctionsElemExpandDotted GeneratedFormatJsonElemFunctionsElem = "expand_dotted"
const GeneratedFormatJsonElemFunctionsElemFilter GeneratedFormatJsonElemFunctionsElem = "filter"
const GeneratedFormatJsonElemFunctionsElemGetBool GeneratedFormatJsonElemFunctionsElem = "get_bool"
const GeneratedFormatJsonElemFunctionsElemGetFloat GeneratedFormatJsonElemFunctionsElem = "get_float"
const GeneratedFormatJsonElemFunctionsElemGetInt GeneratedFormatJsonElemFunctionsElem = "get_int"
const GeneratedFormatJsonElemFunctionsElemGetList GeneratedFormatJsonElemFunctionsElem = "get_list"
const GeneratedFormatJsonElemFunctionsElemGetString GeneratedFormatJsonElemFunctionsElem = "get_string"
const GeneratedFormatJsonElemFunctionsElemLoad GeneratedFormatJsonElemFunctionsElem = "load"
const GeneratedFormatJsonElemFunctionsElemParse GeneratedFormatJsonElemFunctionsElem = "parse"
const GeneratedFormatJsonElemFunctionsElemParseValue GeneratedFormatJsonElemFunctionsElem = "parse_value"
const GeneratedFormatJsonElemFunctionsElemPrettyPrint GeneratedFormatJsonElemFunctionsElem = "pretty_print"
const GeneratedFormatJsonElemFunctionsElemRoundTrip GeneratedFormatJsonElemFunctionsElem = "round_trip"

var enumValues_GeneratedFormatJsonElemFunctionsElem = []interface{}{
	"parse",
	"parse_value",
	"filter",
	"compose",
	"expand_dotted",
	"build_hierarchy",
	"get_string",
	"get_int",
	"get_bool",
	"get_float",
	"get_list",
	"pretty_print",
	"load",
	"canonical_format",
	"round_trip",
	"associativity",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GeneratedFormatJsonElemFunctionsElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GeneratedFormatJsonElemFunctionsElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GeneratedFormatJsonElemFunctionsElem, v)
	}
	*j = GeneratedFormatJsonElemFunctionsElem(v)
	return nil
}

type GeneratedFormatJsonElemValidation string

const GeneratedFormatJsonElemValidationAssociativity GeneratedFormatJsonElemValidation = "associativity"
const GeneratedFormatJsonElemValidationBuildHierarchy GeneratedFormatJsonElemValidation = "build_hierarchy"
const GeneratedFormatJsonElemValidationCanonicalFormat GeneratedFormatJsonElemValidation = "canonical_format"
const GeneratedFormatJsonElemValidationCompose GeneratedFormatJsonElemValidation = "compose"
const GeneratedFormatJsonElemValidationExpandDotted GeneratedFormatJsonElemValidation = "expand_dotted"
const GeneratedFormatJsonElemValidationFilter GeneratedFormatJsonElemValidation = "filter"
const GeneratedFormatJsonElemValidationGetBool GeneratedFormatJsonElemValidation = "get_bool"
const GeneratedFormatJsonElemValidationGetFloat GeneratedFormatJsonElemValidation = "get_float"
const GeneratedFormatJsonElemValidationGetInt GeneratedFormatJsonElemValidation = "get_int"
const GeneratedFormatJsonElemValidationGetList GeneratedFormatJsonElemValidation = "get_list"
const GeneratedFormatJsonElemValidationGetString GeneratedFormatJsonElemValidation = "get_string"
const GeneratedFormatJsonElemValidationLoad GeneratedFormatJsonElemValidation = "load"
const GeneratedFormatJsonElemValidationParse GeneratedFormatJsonElemValidation = "parse"
const GeneratedFormatJsonElemValidationParseValue GeneratedFormatJsonElemValidation = "parse_value"
const GeneratedFormatJsonElemValidationPrettyPrint GeneratedFormatJsonElemValidation = "pretty_print"
const GeneratedFormatJsonElemValidationRoundTrip GeneratedFormatJsonElemValidation = "round_trip"

var enumValues_GeneratedFormatJsonElemValidation = []interface{}{
	"parse",
	"parse_value",
	"filter",
	"compose",
	"expand_dotted",
	"build_hierarchy",
	"get_string",
	"get_int",
	"get_bool",
	"get_float",
	"get_list",
	"pretty_print",
	"load",
	"round_trip",
	"canonical_format",
	"associativity",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GeneratedFormatJsonElemValidation) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GeneratedFormatJsonElemValidation {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GeneratedFormatJsonElemValidation, v)
	}
	*j = GeneratedFormatJsonElemValidation(v)
	return nil
}

type GeneratedFormatJsonElemVariantsElem string

const GeneratedFormatJsonElemVariantsElemProposedBehavior GeneratedFormatJsonElemVariantsElem = "proposed_behavior"
const GeneratedFormatJsonElemVariantsElemReferenceCompliant GeneratedFormatJsonElemVariantsElem = "reference_compliant"

var enumValues_GeneratedFormatJsonElemVariantsElem = []interface{}{
	"proposed_behavior",
	"reference_compliant",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GeneratedFormatJsonElemVariantsElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GeneratedFormatJsonElemVariantsElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GeneratedFormatJsonElemVariantsElem, v)
	}
	*j = GeneratedFormatJsonElemVariantsElem(v)
	return nil
}
