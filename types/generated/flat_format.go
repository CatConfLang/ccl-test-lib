// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package generated

import "encoding/json"
import "fmt"
import "reflect"

// Schema for existing generated flat test files (*-flat.json)
type GeneratedFormatJson struct {
	// JSON Schema reference
	Schema string `json:"$schema" yaml:"$schema" mapstructure:"$schema"`

	// Tests corresponds to the JSON schema field "tests".
	Tests []TestItem `json:"tests" yaml:"tests" mapstructure:"tests"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GeneratedFormatJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["$schema"]; raw != nil && !ok {
		return fmt.Errorf("field $schema in GeneratedFormatJson: required")
	}
	if _, ok := raw["tests"]; raw != nil && !ok {
		return fmt.Errorf("field tests in GeneratedFormatJson: required")
	}
	type Plain GeneratedFormatJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Tests != nil && len(plain.Tests) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "tests", 1)
	}
	*j = GeneratedFormatJson(plain)
	return nil
}

type TestItem interface{}

type TestItemBehaviorsElem string

const TestItemBehaviorsElemBooleanLenient TestItemBehaviorsElem = "boolean_lenient"
const TestItemBehaviorsElemBooleanStrict TestItemBehaviorsElem = "boolean_strict"
const TestItemBehaviorsElemCrlfNormalizeToLf TestItemBehaviorsElem = "crlf_normalize_to_lf"
const TestItemBehaviorsElemCrlfPreserveLiteral TestItemBehaviorsElem = "crlf_preserve_literal"
const TestItemBehaviorsElemListCoercionDisabled TestItemBehaviorsElem = "list_coercion_disabled"
const TestItemBehaviorsElemListCoercionEnabled TestItemBehaviorsElem = "list_coercion_enabled"
const TestItemBehaviorsElemLooseSpacing TestItemBehaviorsElem = "loose_spacing"
const TestItemBehaviorsElemStrictSpacing TestItemBehaviorsElem = "strict_spacing"
const TestItemBehaviorsElemTabsPreserve TestItemBehaviorsElem = "tabs_preserve"
const TestItemBehaviorsElemTabsToSpaces TestItemBehaviorsElem = "tabs_to_spaces"

var enumValues_TestItemBehaviorsElem = []interface{}{
	"boolean_strict",
	"boolean_lenient",
	"crlf_preserve_literal",
	"crlf_normalize_to_lf",
	"tabs_preserve",
	"tabs_to_spaces",
	"strict_spacing",
	"loose_spacing",
	"list_coercion_enabled",
	"list_coercion_disabled",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TestItemBehaviorsElem) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TestItemBehaviorsElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TestItemBehaviorsElem, v)
	}
	*j = TestItemBehaviorsElem(v)
	return nil
}

// Mutually exclusive options by category
type TestItemConflicts struct {
	// Behaviors corresponds to the JSON schema field "behaviors".
	Behaviors []string `json:"behaviors,omitempty" yaml:"behaviors,omitempty" mapstructure:"behaviors,omitempty"`

	// Features corresponds to the JSON schema field "features".
	Features []string `json:"features,omitempty" yaml:"features,omitempty" mapstructure:"features,omitempty"`

	// Functions corresponds to the JSON schema field "functions".
	Functions []string `json:"functions,omitempty" yaml:"functions,omitempty" mapstructure:"functions,omitempty"`

	// Variants corresponds to the JSON schema field "variants".
	Variants []string `json:"variants,omitempty" yaml:"variants,omitempty" mapstructure:"variants,omitempty"`
}

// Expected result in standardized format
type TestItemExpected struct {
	// Number of expected results/assertions
	Count int `json:"count" yaml:"count" mapstructure:"count"`

	// Expected entries for parse functions
	Entries []TestItemExpectedEntriesElem `json:"entries,omitempty" yaml:"entries,omitempty" mapstructure:"entries,omitempty"`

	// Whether this should produce an error
	Error bool `json:"error,omitempty" yaml:"error,omitempty" mapstructure:"error,omitempty"`

	// Expected list for list access functions
	List []interface{} `json:"list,omitempty" yaml:"list,omitempty" mapstructure:"list,omitempty"`

	// Expected object for hierarchy functions
	Object interface{} `json:"object,omitempty" yaml:"object,omitempty" mapstructure:"object,omitempty"`

	// Expected single value for typed access functions
	Value interface{} `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`
}

type TestItemExpectedEntriesElem struct {
	// Key corresponds to the JSON schema field "key".
	Key string `json:"key" yaml:"key" mapstructure:"key"`

	// Value corresponds to the JSON schema field "value".
	Value string `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TestItemExpectedEntriesElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["key"]; raw != nil && !ok {
		return fmt.Errorf("field key in TestItemExpectedEntriesElem: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in TestItemExpectedEntriesElem: required")
	}
	type Plain TestItemExpectedEntriesElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = TestItemExpectedEntriesElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TestItemExpected) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["count"]; raw != nil && !ok {
		return fmt.Errorf("field count in TestItemExpected: required")
	}
	type Plain TestItemExpected
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if 0 > plain.Count {
		return fmt.Errorf("field %s: must be >= %v", "count", 0)
	}
	if v, ok := raw["error"]; !ok || v == nil {
		plain.Error = false
	}
	*j = TestItemExpected(plain)
	return nil
}

type TestItemFeaturesElem string

const TestItemFeaturesElemComments TestItemFeaturesElem = "comments"
const TestItemFeaturesElemEmptyKeys TestItemFeaturesElem = "empty_keys"
const TestItemFeaturesElemExperimentalDottedKeys TestItemFeaturesElem = "experimental_dotted_keys"
const TestItemFeaturesElemMultiline TestItemFeaturesElem = "multiline"
const TestItemFeaturesElemUnicode TestItemFeaturesElem = "unicode"
const TestItemFeaturesElemWhitespace TestItemFeaturesElem = "whitespace"

var enumValues_TestItemFeaturesElem = []interface{}{
	"comments",
	"empty_keys",
	"experimental_dotted_keys",
	"multiline",
	"unicode",
	"whitespace",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TestItemFeaturesElem) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TestItemFeaturesElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TestItemFeaturesElem, v)
	}
	*j = TestItemFeaturesElem(v)
	return nil
}

type TestItemFunctionsElem string

const TestItemFunctionsElemAssociativity TestItemFunctionsElem = "associativity"
const TestItemFunctionsElemBuildHierarchy TestItemFunctionsElem = "build_hierarchy"
const TestItemFunctionsElemCanonicalFormat TestItemFunctionsElem = "canonical_format"
const TestItemFunctionsElemCompose TestItemFunctionsElem = "compose"
const TestItemFunctionsElemExpandDotted TestItemFunctionsElem = "expand_dotted"
const TestItemFunctionsElemFilter TestItemFunctionsElem = "filter"
const TestItemFunctionsElemGetBool TestItemFunctionsElem = "get_bool"
const TestItemFunctionsElemGetFloat TestItemFunctionsElem = "get_float"
const TestItemFunctionsElemGetInt TestItemFunctionsElem = "get_int"
const TestItemFunctionsElemGetList TestItemFunctionsElem = "get_list"
const TestItemFunctionsElemGetString TestItemFunctionsElem = "get_string"
const TestItemFunctionsElemLoad TestItemFunctionsElem = "load"
const TestItemFunctionsElemParse TestItemFunctionsElem = "parse"
const TestItemFunctionsElemParseValue TestItemFunctionsElem = "parse_value"
const TestItemFunctionsElemRoundTrip TestItemFunctionsElem = "round_trip"

var enumValues_TestItemFunctionsElem = []interface{}{
	"parse",
	"parse_value",
	"filter",
	"compose",
	"expand_dotted",
	"build_hierarchy",
	"get_string",
	"get_int",
	"get_bool",
	"get_float",
	"get_list",
	"canonical_format",
	"load",
	"round_trip",
	"associativity",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TestItemFunctionsElem) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TestItemFunctionsElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TestItemFunctionsElem, v)
	}
	*j = TestItemFunctionsElem(v)
	return nil
}

type TestItemValidation string

const TestItemValidationAssociativity TestItemValidation = "associativity"
const TestItemValidationBuildHierarchy TestItemValidation = "build_hierarchy"
const TestItemValidationCanonicalFormat TestItemValidation = "canonical_format"
const TestItemValidationCompose TestItemValidation = "compose"
const TestItemValidationExpandDotted TestItemValidation = "expand_dotted"
const TestItemValidationFilter TestItemValidation = "filter"
const TestItemValidationGetBool TestItemValidation = "get_bool"
const TestItemValidationGetFloat TestItemValidation = "get_float"
const TestItemValidationGetInt TestItemValidation = "get_int"
const TestItemValidationGetList TestItemValidation = "get_list"
const TestItemValidationGetString TestItemValidation = "get_string"
const TestItemValidationLoad TestItemValidation = "load"
const TestItemValidationParse TestItemValidation = "parse"
const TestItemValidationParseValue TestItemValidation = "parse_value"
const TestItemValidationRoundTrip TestItemValidation = "round_trip"

var enumValues_TestItemValidation = []interface{}{
	"parse",
	"parse_value",
	"filter",
	"compose",
	"expand_dotted",
	"build_hierarchy",
	"get_string",
	"get_int",
	"get_bool",
	"get_float",
	"get_list",
	"canonical_format",
	"load",
	"round_trip",
	"associativity",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TestItemValidation) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TestItemValidation {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TestItemValidation, v)
	}
	*j = TestItemValidation(v)
	return nil
}

type TestItemVariantsElem string

const TestItemVariantsElemProposedBehavior TestItemVariantsElem = "proposed_behavior"
const TestItemVariantsElemReferenceCompliant TestItemVariantsElem = "reference_compliant"

var enumValues_TestItemVariantsElem = []interface{}{
	"proposed_behavior",
	"reference_compliant",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TestItemVariantsElem) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TestItemVariantsElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TestItemVariantsElem, v)
	}
	*j = TestItemVariantsElem(v)
	return nil
}
