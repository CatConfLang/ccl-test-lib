// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package generated

import "encoding/json"
import "fmt"
import "reflect"
import "regexp"

// Schema for source test files (api_*.json)
type SourceFormatJson struct {
	// JSON Schema reference (relative path to schema file)
	Schema *string `json:"$schema,omitempty" yaml:"$schema,omitempty" mapstructure:"$schema,omitempty"`

	// Array of test cases
	Tests []SourceFormatJsonTestsElem `json:"tests" yaml:"tests" mapstructure:"tests"`
}

type SourceFormatJsonTestsElem struct {
	// Implementation behavior requirements (optional)
	Behaviors []SourceFormatJsonTestsElemBehaviorsElem `json:"behaviors,omitempty" yaml:"behaviors,omitempty" mapstructure:"behaviors,omitempty"`

	// Mutually exclusive options by category (optional)
	Conflicts *SourceFormatJsonTestsElemConflicts `json:"conflicts,omitempty" yaml:"conflicts,omitempty" mapstructure:"conflicts,omitempty"`

	// Required language features for this test
	Features []string `json:"features,omitempty" yaml:"features,omitempty" mapstructure:"features,omitempty"`

	// CCL input text(s) to be tested. Single-input tests use a 1-element array.
	Inputs []string `json:"inputs" yaml:"inputs" mapstructure:"inputs"`

	// Unique test name identifier
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Array of test validations
	Tests []SourceFormatJsonTestsElemTestsElem `json:"tests" yaml:"tests" mapstructure:"tests"`

	// Specification variants (optional)
	Variants []SourceFormatJsonTestsElemVariantsElem `json:"variants,omitempty" yaml:"variants,omitempty" mapstructure:"variants,omitempty"`
}

type SourceFormatJsonTestsElemBehaviorsElem string

const SourceFormatJsonTestsElemBehaviorsElemArrayOrderInsertion SourceFormatJsonTestsElemBehaviorsElem = "array_order_insertion"
const SourceFormatJsonTestsElemBehaviorsElemArrayOrderLexicographic SourceFormatJsonTestsElemBehaviorsElem = "array_order_lexicographic"
const SourceFormatJsonTestsElemBehaviorsElemBooleanLenient SourceFormatJsonTestsElemBehaviorsElem = "boolean_lenient"
const SourceFormatJsonTestsElemBehaviorsElemBooleanStrict SourceFormatJsonTestsElemBehaviorsElem = "boolean_strict"
const SourceFormatJsonTestsElemBehaviorsElemCrlfNormalizeToLf SourceFormatJsonTestsElemBehaviorsElem = "crlf_normalize_to_lf"
const SourceFormatJsonTestsElemBehaviorsElemCrlfPreserveLiteral SourceFormatJsonTestsElemBehaviorsElem = "crlf_preserve_literal"
const SourceFormatJsonTestsElemBehaviorsElemListCoercionDisabled SourceFormatJsonTestsElemBehaviorsElem = "list_coercion_disabled"
const SourceFormatJsonTestsElemBehaviorsElemListCoercionEnabled SourceFormatJsonTestsElemBehaviorsElem = "list_coercion_enabled"
const SourceFormatJsonTestsElemBehaviorsElemLooseSpacing SourceFormatJsonTestsElemBehaviorsElem = "loose_spacing"
const SourceFormatJsonTestsElemBehaviorsElemStrictSpacing SourceFormatJsonTestsElemBehaviorsElem = "strict_spacing"
const SourceFormatJsonTestsElemBehaviorsElemTabsPreserve SourceFormatJsonTestsElemBehaviorsElem = "tabs_preserve"
const SourceFormatJsonTestsElemBehaviorsElemTabsToSpaces SourceFormatJsonTestsElemBehaviorsElem = "tabs_to_spaces"

var enumValues_SourceFormatJsonTestsElemBehaviorsElem = []interface{}{
	"boolean_strict",
	"boolean_lenient",
	"crlf_preserve_literal",
	"crlf_normalize_to_lf",
	"tabs_preserve",
	"tabs_to_spaces",
	"strict_spacing",
	"loose_spacing",
	"list_coercion_enabled",
	"list_coercion_disabled",
	"array_order_insertion",
	"array_order_lexicographic",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SourceFormatJsonTestsElemBehaviorsElem) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SourceFormatJsonTestsElemBehaviorsElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SourceFormatJsonTestsElemBehaviorsElem, v)
	}
	*j = SourceFormatJsonTestsElemBehaviorsElem(v)
	return nil
}

// Mutually exclusive options by category (optional)
type SourceFormatJsonTestsElemConflicts struct {
	// Behaviors that conflict with this test's requirements
	Behaviors []string `json:"behaviors,omitempty" yaml:"behaviors,omitempty" mapstructure:"behaviors,omitempty"`

	// Features that conflict with this test
	Features []string `json:"features,omitempty" yaml:"features,omitempty" mapstructure:"features,omitempty"`

	// Functions that conflict with this test
	Functions []string `json:"functions,omitempty" yaml:"functions,omitempty" mapstructure:"functions,omitempty"`

	// Variants that conflict with this test
	Variants []string `json:"variants,omitempty" yaml:"variants,omitempty" mapstructure:"variants,omitempty"`
}

type SourceFormatJsonTestsElemTestsElem struct {
	// Optional arguments for parameterized functions
	Args []string `json:"args,omitempty" yaml:"args,omitempty" mapstructure:"args,omitempty"`

	// Whether function should produce an error
	Error bool `json:"error,omitempty" yaml:"error,omitempty" mapstructure:"error,omitempty"`

	// Expected result from the function
	Expect interface{} `json:"expect" yaml:"expect" mapstructure:"expect"`

	// CCL function to test
	Function SourceFormatJsonTestsElemTestsElemFunction `json:"function" yaml:"function" mapstructure:"function"`
}

type SourceFormatJsonTestsElemTestsElemFunction string

const SourceFormatJsonTestsElemTestsElemFunctionBuildHierarchy SourceFormatJsonTestsElemTestsElemFunction = "build_hierarchy"
const SourceFormatJsonTestsElemTestsElemFunctionCanonicalFormat SourceFormatJsonTestsElemTestsElemFunction = "canonical_format"
const SourceFormatJsonTestsElemTestsElemFunctionCompose SourceFormatJsonTestsElemTestsElemFunction = "compose"
const SourceFormatJsonTestsElemTestsElemFunctionComposeAssociative SourceFormatJsonTestsElemTestsElemFunction = "compose_associative"
const SourceFormatJsonTestsElemTestsElemFunctionFilter SourceFormatJsonTestsElemTestsElemFunction = "filter"
const SourceFormatJsonTestsElemTestsElemFunctionGetBool SourceFormatJsonTestsElemTestsElemFunction = "get_bool"
const SourceFormatJsonTestsElemTestsElemFunctionGetFloat SourceFormatJsonTestsElemTestsElemFunction = "get_float"
const SourceFormatJsonTestsElemTestsElemFunctionGetInt SourceFormatJsonTestsElemTestsElemFunction = "get_int"
const SourceFormatJsonTestsElemTestsElemFunctionGetList SourceFormatJsonTestsElemTestsElemFunction = "get_list"
const SourceFormatJsonTestsElemTestsElemFunctionGetString SourceFormatJsonTestsElemTestsElemFunction = "get_string"
const SourceFormatJsonTestsElemTestsElemFunctionIdentityLeft SourceFormatJsonTestsElemTestsElemFunction = "identity_left"
const SourceFormatJsonTestsElemTestsElemFunctionIdentityRight SourceFormatJsonTestsElemTestsElemFunction = "identity_right"
const SourceFormatJsonTestsElemTestsElemFunctionLoad SourceFormatJsonTestsElemTestsElemFunction = "load"
const SourceFormatJsonTestsElemTestsElemFunctionParse SourceFormatJsonTestsElemTestsElemFunction = "parse"
const SourceFormatJsonTestsElemTestsElemFunctionParseIndented SourceFormatJsonTestsElemTestsElemFunction = "parse_indented"
const SourceFormatJsonTestsElemTestsElemFunctionPrint SourceFormatJsonTestsElemTestsElemFunction = "print"
const SourceFormatJsonTestsElemTestsElemFunctionRoundTrip SourceFormatJsonTestsElemTestsElemFunction = "round_trip"

var enumValues_SourceFormatJsonTestsElemTestsElemFunction = []interface{}{
	"parse",
	"parse_indented",
	"filter",
	"compose",
	"build_hierarchy",
	"get_string",
	"get_int",
	"get_bool",
	"get_float",
	"get_list",
	"print",
	"canonical_format",
	"load",
	"round_trip",
	"compose_associative",
	"identity_left",
	"identity_right",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SourceFormatJsonTestsElemTestsElemFunction) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SourceFormatJsonTestsElemTestsElemFunction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SourceFormatJsonTestsElemTestsElemFunction, v)
	}
	*j = SourceFormatJsonTestsElemTestsElemFunction(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SourceFormatJsonTestsElemTestsElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["expect"]; raw != nil && !ok {
		return fmt.Errorf("field expect in SourceFormatJsonTestsElemTestsElem: required")
	}
	if _, ok := raw["function"]; raw != nil && !ok {
		return fmt.Errorf("field function in SourceFormatJsonTestsElemTestsElem: required")
	}
	type Plain SourceFormatJsonTestsElemTestsElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["error"]; !ok || v == nil {
		plain.Error = false
	}
	*j = SourceFormatJsonTestsElemTestsElem(plain)
	return nil
}

type SourceFormatJsonTestsElemVariantsElem string

const SourceFormatJsonTestsElemVariantsElemProposedBehavior SourceFormatJsonTestsElemVariantsElem = "proposed_behavior"
const SourceFormatJsonTestsElemVariantsElemReferenceCompliant SourceFormatJsonTestsElemVariantsElem = "reference_compliant"

var enumValues_SourceFormatJsonTestsElemVariantsElem = []interface{}{
	"proposed_behavior",
	"reference_compliant",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SourceFormatJsonTestsElemVariantsElem) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SourceFormatJsonTestsElemVariantsElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SourceFormatJsonTestsElemVariantsElem, v)
	}
	*j = SourceFormatJsonTestsElemVariantsElem(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SourceFormatJsonTestsElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["inputs"]; raw != nil && !ok {
		return fmt.Errorf("field inputs in SourceFormatJsonTestsElem: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in SourceFormatJsonTestsElem: required")
	}
	if _, ok := raw["tests"]; raw != nil && !ok {
		return fmt.Errorf("field tests in SourceFormatJsonTestsElem: required")
	}
	type Plain SourceFormatJsonTestsElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Inputs != nil && len(plain.Inputs) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "inputs", 1)
	}
	if matched, _ := regexp.MatchString(`^[a-zA-Z0-9_]+$`, string(plain.Name)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "Name", `^[a-zA-Z0-9_]+$`)
	}
	if plain.Tests != nil && len(plain.Tests) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "tests", 1)
	}
	*j = SourceFormatJsonTestsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SourceFormatJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["tests"]; raw != nil && !ok {
		return fmt.Errorf("field tests in SourceFormatJson: required")
	}
	type Plain SourceFormatJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Tests != nil && len(plain.Tests) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "tests", 1)
	}
	*j = SourceFormatJson(plain)
	return nil
}
