// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package generated

import "encoding/json"
import "fmt"
import "reflect"

// Schema for existing source test files (api_*.json) with current structure
type SourceFormatJson []struct {
	// Implementation behavior requirements (optional)
	Behaviors []SourceFormatJsonElemBehaviorsElem `json:"behaviors,omitempty" yaml:"behaviors,omitempty" mapstructure:"behaviors,omitempty"`

	// Mutually exclusive options by category (optional)
	Conflicts *SourceFormatJsonElemConflicts `json:"conflicts,omitempty" yaml:"conflicts,omitempty" mapstructure:"conflicts,omitempty"`

	// Required language features for this test
	Features []SourceFormatJsonElemFeaturesElem `json:"features,omitempty" yaml:"features,omitempty" mapstructure:"features,omitempty"`

	// CCL input text to be tested
	Input string `json:"input" yaml:"input" mapstructure:"input"`

	// CCL implementation level (1-5)
	Level *int `json:"level,omitempty" yaml:"level,omitempty" mapstructure:"level,omitempty"`

	// Unique test name identifier
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Array of test validations
	Tests []SourceFormatJsonElemTestsElem `json:"tests" yaml:"tests" mapstructure:"tests"`

	// Specification variants (optional)
	Variants []SourceFormatJsonElemVariantsElem `json:"variants,omitempty" yaml:"variants,omitempty" mapstructure:"variants,omitempty"`
}

type SourceFormatJsonElemBehaviorsElem string

const SourceFormatJsonElemBehaviorsElemBooleanLenient SourceFormatJsonElemBehaviorsElem = "boolean_lenient"
const SourceFormatJsonElemBehaviorsElemBooleanStrict SourceFormatJsonElemBehaviorsElem = "boolean_strict"
const SourceFormatJsonElemBehaviorsElemCrlfNormalizeToLf SourceFormatJsonElemBehaviorsElem = "crlf_normalize_to_lf"
const SourceFormatJsonElemBehaviorsElemCrlfPreserveLiteral SourceFormatJsonElemBehaviorsElem = "crlf_preserve_literal"
const SourceFormatJsonElemBehaviorsElemListCoercionDisabled SourceFormatJsonElemBehaviorsElem = "list_coercion_disabled"
const SourceFormatJsonElemBehaviorsElemListCoercionEnabled SourceFormatJsonElemBehaviorsElem = "list_coercion_enabled"
const SourceFormatJsonElemBehaviorsElemLooseSpacing SourceFormatJsonElemBehaviorsElem = "loose_spacing"
const SourceFormatJsonElemBehaviorsElemStrictSpacing SourceFormatJsonElemBehaviorsElem = "strict_spacing"
const SourceFormatJsonElemBehaviorsElemTabsPreserve SourceFormatJsonElemBehaviorsElem = "tabs_preserve"
const SourceFormatJsonElemBehaviorsElemTabsToSpaces SourceFormatJsonElemBehaviorsElem = "tabs_to_spaces"

var enumValues_SourceFormatJsonElemBehaviorsElem = []interface{}{
	"boolean_strict",
	"boolean_lenient",
	"crlf_preserve_literal",
	"crlf_normalize_to_lf",
	"tabs_preserve",
	"tabs_to_spaces",
	"strict_spacing",
	"loose_spacing",
	"list_coercion_enabled",
	"list_coercion_disabled",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SourceFormatJsonElemBehaviorsElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SourceFormatJsonElemBehaviorsElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SourceFormatJsonElemBehaviorsElem, v)
	}
	*j = SourceFormatJsonElemBehaviorsElem(v)
	return nil
}

// Mutually exclusive options by category (optional)
type SourceFormatJsonElemConflicts struct {
	// Behaviors that conflict with this test's requirements
	Behaviors []string `json:"behaviors,omitempty" yaml:"behaviors,omitempty" mapstructure:"behaviors,omitempty"`

	// Features that conflict with this test
	Features []string `json:"features,omitempty" yaml:"features,omitempty" mapstructure:"features,omitempty"`

	// Functions that conflict with this test
	Functions []string `json:"functions,omitempty" yaml:"functions,omitempty" mapstructure:"functions,omitempty"`

	// Variants that conflict with this test
	Variants []string `json:"variants,omitempty" yaml:"variants,omitempty" mapstructure:"variants,omitempty"`
}

type SourceFormatJsonElemFeaturesElem string

const SourceFormatJsonElemFeaturesElemComments SourceFormatJsonElemFeaturesElem = "comments"
const SourceFormatJsonElemFeaturesElemEmptyKeys SourceFormatJsonElemFeaturesElem = "empty_keys"
const SourceFormatJsonElemFeaturesElemExperimentalDottedKeys SourceFormatJsonElemFeaturesElem = "experimental_dotted_keys"
const SourceFormatJsonElemFeaturesElemMultiline SourceFormatJsonElemFeaturesElem = "multiline"
const SourceFormatJsonElemFeaturesElemUnicode SourceFormatJsonElemFeaturesElem = "unicode"
const SourceFormatJsonElemFeaturesElemWhitespace SourceFormatJsonElemFeaturesElem = "whitespace"

var enumValues_SourceFormatJsonElemFeaturesElem = []interface{}{
	"comments",
	"empty_keys",
	"experimental_dotted_keys",
	"multiline",
	"unicode",
	"whitespace",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SourceFormatJsonElemFeaturesElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SourceFormatJsonElemFeaturesElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SourceFormatJsonElemFeaturesElem, v)
	}
	*j = SourceFormatJsonElemFeaturesElem(v)
	return nil
}

type SourceFormatJsonElemTestsElem struct {
	// Optional arguments for parameterized functions
	Args []string `json:"args,omitempty" yaml:"args,omitempty" mapstructure:"args,omitempty"`

	// Whether function should produce an error
	Error bool `json:"error,omitempty" yaml:"error,omitempty" mapstructure:"error,omitempty"`

	// Expected result from the function
	Expect interface{} `json:"expect" yaml:"expect" mapstructure:"expect"`

	// CCL function to test
	Function SourceFormatJsonElemTestsElemFunction `json:"function" yaml:"function" mapstructure:"function"`
}

type SourceFormatJsonElemTestsElemFunction string

const SourceFormatJsonElemTestsElemFunctionAssociativity SourceFormatJsonElemTestsElemFunction = "associativity"
const SourceFormatJsonElemTestsElemFunctionBuildHierarchy SourceFormatJsonElemTestsElemFunction = "build_hierarchy"
const SourceFormatJsonElemTestsElemFunctionCanonicalFormat SourceFormatJsonElemTestsElemFunction = "canonical_format"
const SourceFormatJsonElemTestsElemFunctionCompose SourceFormatJsonElemTestsElemFunction = "compose"
const SourceFormatJsonElemTestsElemFunctionExpandDotted SourceFormatJsonElemTestsElemFunction = "expand_dotted"
const SourceFormatJsonElemTestsElemFunctionFilter SourceFormatJsonElemTestsElemFunction = "filter"
const SourceFormatJsonElemTestsElemFunctionGetBool SourceFormatJsonElemTestsElemFunction = "get_bool"
const SourceFormatJsonElemTestsElemFunctionGetFloat SourceFormatJsonElemTestsElemFunction = "get_float"
const SourceFormatJsonElemTestsElemFunctionGetInt SourceFormatJsonElemTestsElemFunction = "get_int"
const SourceFormatJsonElemTestsElemFunctionGetList SourceFormatJsonElemTestsElemFunction = "get_list"
const SourceFormatJsonElemTestsElemFunctionGetString SourceFormatJsonElemTestsElemFunction = "get_string"
const SourceFormatJsonElemTestsElemFunctionLoad SourceFormatJsonElemTestsElemFunction = "load"
const SourceFormatJsonElemTestsElemFunctionParse SourceFormatJsonElemTestsElemFunction = "parse"
const SourceFormatJsonElemTestsElemFunctionParseValue SourceFormatJsonElemTestsElemFunction = "parse_value"
const SourceFormatJsonElemTestsElemFunctionPrettyPrint SourceFormatJsonElemTestsElemFunction = "pretty_print"
const SourceFormatJsonElemTestsElemFunctionRoundTrip SourceFormatJsonElemTestsElemFunction = "round_trip"

var enumValues_SourceFormatJsonElemTestsElemFunction = []interface{}{
	"parse",
	"parse_value",
	"filter",
	"compose",
	"expand_dotted",
	"build_hierarchy",
	"get_string",
	"get_int",
	"get_bool",
	"get_float",
	"get_list",
	"pretty_print",
	"load",
	"round_trip",
	"canonical_format",
	"associativity",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SourceFormatJsonElemTestsElemFunction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SourceFormatJsonElemTestsElemFunction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SourceFormatJsonElemTestsElemFunction, v)
	}
	*j = SourceFormatJsonElemTestsElemFunction(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SourceFormatJsonElemTestsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["expect"]; raw != nil && !ok {
		return fmt.Errorf("field expect in SourceFormatJsonElemTestsElem: required")
	}
	if _, ok := raw["function"]; raw != nil && !ok {
		return fmt.Errorf("field function in SourceFormatJsonElemTestsElem: required")
	}
	type Plain SourceFormatJsonElemTestsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["error"]; !ok || v == nil {
		plain.Error = false
	}
	*j = SourceFormatJsonElemTestsElem(plain)
	return nil
}

type SourceFormatJsonElemVariantsElem string

const SourceFormatJsonElemVariantsElemProposedBehavior SourceFormatJsonElemVariantsElem = "proposed_behavior"
const SourceFormatJsonElemVariantsElemReferenceCompliant SourceFormatJsonElemVariantsElem = "reference_compliant"

var enumValues_SourceFormatJsonElemVariantsElem = []interface{}{
	"proposed_behavior",
	"reference_compliant",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SourceFormatJsonElemVariantsElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SourceFormatJsonElemVariantsElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SourceFormatJsonElemVariantsElem, v)
	}
	*j = SourceFormatJsonElemVariantsElem(v)
	return nil
}
