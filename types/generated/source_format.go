// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package generated

import "encoding/json"
import "fmt"
import "reflect"

// Schema for source test files (api_*.json) with $schema field support
type SourceFormatJson struct {
	// JSON Schema reference
	Schema *string `json:"$schema,omitempty" yaml:"$schema,omitempty" mapstructure:"$schema,omitempty"`

	// Array of test cases
	Tests []SourceFormatJsonTestsElem `json:"tests" yaml:"tests" mapstructure:"tests"`
}

type SourceFormatJsonTestsElem struct {
	// Implementation behavior requirements (optional)
	Behaviors []SourceFormatJsonTestsElemBehaviorsElem `json:"behaviors,omitempty" yaml:"behaviors,omitempty" mapstructure:"behaviors,omitempty"`

	// Mutually exclusive options by category (optional)
	Conflicts *SourceFormatJsonTestsElemConflicts `json:"conflicts,omitempty" yaml:"conflicts,omitempty" mapstructure:"conflicts,omitempty"`

	// Required language features for this test
	Features []SourceFormatJsonTestsElemFeaturesElem `json:"features,omitempty" yaml:"features,omitempty" mapstructure:"features,omitempty"`

	// CCL input text to be tested
	Input string `json:"input" yaml:"input" mapstructure:"input"`

	// CCL implementation level (1-5)
	Level *int `json:"level,omitempty" yaml:"level,omitempty" mapstructure:"level,omitempty"`

	// Unique test name identifier
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Array of test validations
	Tests []SourceFormatJsonTestsElemTestsElem `json:"tests" yaml:"tests" mapstructure:"tests"`

	// Specification variants (optional)
	Variants []SourceFormatJsonTestsElemVariantsElem `json:"variants,omitempty" yaml:"variants,omitempty" mapstructure:"variants,omitempty"`
}

type SourceFormatJsonTestsElemBehaviorsElem string

const SourceFormatJsonTestsElemBehaviorsElemBooleanLenient SourceFormatJsonTestsElemBehaviorsElem = "boolean_lenient"
const SourceFormatJsonTestsElemBehaviorsElemBooleanStrict SourceFormatJsonTestsElemBehaviorsElem = "boolean_strict"
const SourceFormatJsonTestsElemBehaviorsElemCrlfNormalizeToLf SourceFormatJsonTestsElemBehaviorsElem = "crlf_normalize_to_lf"
const SourceFormatJsonTestsElemBehaviorsElemCrlfPreserveLiteral SourceFormatJsonTestsElemBehaviorsElem = "crlf_preserve_literal"
const SourceFormatJsonTestsElemBehaviorsElemListCoercionDisabled SourceFormatJsonTestsElemBehaviorsElem = "list_coercion_disabled"
const SourceFormatJsonTestsElemBehaviorsElemListCoercionEnabled SourceFormatJsonTestsElemBehaviorsElem = "list_coercion_enabled"
const SourceFormatJsonTestsElemBehaviorsElemLooseSpacing SourceFormatJsonTestsElemBehaviorsElem = "loose_spacing"
const SourceFormatJsonTestsElemBehaviorsElemStrictSpacing SourceFormatJsonTestsElemBehaviorsElem = "strict_spacing"
const SourceFormatJsonTestsElemBehaviorsElemTabsPreserve SourceFormatJsonTestsElemBehaviorsElem = "tabs_preserve"
const SourceFormatJsonTestsElemBehaviorsElemTabsToSpaces SourceFormatJsonTestsElemBehaviorsElem = "tabs_to_spaces"

var enumValues_SourceFormatJsonTestsElemBehaviorsElem = []interface{}{
	"boolean_strict",
	"boolean_lenient",
	"crlf_preserve_literal",
	"crlf_normalize_to_lf",
	"tabs_preserve",
	"tabs_to_spaces",
	"strict_spacing",
	"loose_spacing",
	"list_coercion_enabled",
	"list_coercion_disabled",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SourceFormatJsonTestsElemBehaviorsElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SourceFormatJsonTestsElemBehaviorsElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SourceFormatJsonTestsElemBehaviorsElem, v)
	}
	*j = SourceFormatJsonTestsElemBehaviorsElem(v)
	return nil
}

// Mutually exclusive options by category (optional)
type SourceFormatJsonTestsElemConflicts struct {
	// Behaviors that conflict with this test's requirements
	Behaviors []string `json:"behaviors,omitempty" yaml:"behaviors,omitempty" mapstructure:"behaviors,omitempty"`

	// Features that conflict with this test
	Features []string `json:"features,omitempty" yaml:"features,omitempty" mapstructure:"features,omitempty"`

	// Functions that conflict with this test
	Functions []string `json:"functions,omitempty" yaml:"functions,omitempty" mapstructure:"functions,omitempty"`

	// Variants that conflict with this test
	Variants []string `json:"variants,omitempty" yaml:"variants,omitempty" mapstructure:"variants,omitempty"`
}

type SourceFormatJsonTestsElemFeaturesElem string

const SourceFormatJsonTestsElemFeaturesElemComments SourceFormatJsonTestsElemFeaturesElem = "comments"
const SourceFormatJsonTestsElemFeaturesElemEmptyKeys SourceFormatJsonTestsElemFeaturesElem = "empty_keys"
const SourceFormatJsonTestsElemFeaturesElemExperimentalDottedKeys SourceFormatJsonTestsElemFeaturesElem = "experimental_dotted_keys"
const SourceFormatJsonTestsElemFeaturesElemMultiline SourceFormatJsonTestsElemFeaturesElem = "multiline"
const SourceFormatJsonTestsElemFeaturesElemUnicode SourceFormatJsonTestsElemFeaturesElem = "unicode"
const SourceFormatJsonTestsElemFeaturesElemWhitespace SourceFormatJsonTestsElemFeaturesElem = "whitespace"

var enumValues_SourceFormatJsonTestsElemFeaturesElem = []interface{}{
	"comments",
	"empty_keys",
	"experimental_dotted_keys",
	"multiline",
	"unicode",
	"whitespace",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SourceFormatJsonTestsElemFeaturesElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SourceFormatJsonTestsElemFeaturesElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SourceFormatJsonTestsElemFeaturesElem, v)
	}
	*j = SourceFormatJsonTestsElemFeaturesElem(v)
	return nil
}

type SourceFormatJsonTestsElemTestsElem struct {
	// Optional arguments for parameterized functions
	Args []string `json:"args,omitempty" yaml:"args,omitempty" mapstructure:"args,omitempty"`

	// Whether function should produce an error
	Error bool `json:"error,omitempty" yaml:"error,omitempty" mapstructure:"error,omitempty"`

	// Expected result from the function
	Expect interface{} `json:"expect" yaml:"expect" mapstructure:"expect"`

	// CCL function to test
	Function SourceFormatJsonTestsElemTestsElemFunction `json:"function" yaml:"function" mapstructure:"function"`
}

type SourceFormatJsonTestsElemTestsElemFunction string

const SourceFormatJsonTestsElemTestsElemFunctionAssociativity SourceFormatJsonTestsElemTestsElemFunction = "associativity"
const SourceFormatJsonTestsElemTestsElemFunctionBuildHierarchy SourceFormatJsonTestsElemTestsElemFunction = "build_hierarchy"
const SourceFormatJsonTestsElemTestsElemFunctionCanonicalFormat SourceFormatJsonTestsElemTestsElemFunction = "canonical_format"
const SourceFormatJsonTestsElemTestsElemFunctionCompose SourceFormatJsonTestsElemTestsElemFunction = "compose"
const SourceFormatJsonTestsElemTestsElemFunctionExpandDotted SourceFormatJsonTestsElemTestsElemFunction = "expand_dotted"
const SourceFormatJsonTestsElemTestsElemFunctionFilter SourceFormatJsonTestsElemTestsElemFunction = "filter"
const SourceFormatJsonTestsElemTestsElemFunctionGetBool SourceFormatJsonTestsElemTestsElemFunction = "get_bool"
const SourceFormatJsonTestsElemTestsElemFunctionGetFloat SourceFormatJsonTestsElemTestsElemFunction = "get_float"
const SourceFormatJsonTestsElemTestsElemFunctionGetInt SourceFormatJsonTestsElemTestsElemFunction = "get_int"
const SourceFormatJsonTestsElemTestsElemFunctionGetList SourceFormatJsonTestsElemTestsElemFunction = "get_list"
const SourceFormatJsonTestsElemTestsElemFunctionGetString SourceFormatJsonTestsElemTestsElemFunction = "get_string"
const SourceFormatJsonTestsElemTestsElemFunctionLoad SourceFormatJsonTestsElemTestsElemFunction = "load"
const SourceFormatJsonTestsElemTestsElemFunctionParse SourceFormatJsonTestsElemTestsElemFunction = "parse"
const SourceFormatJsonTestsElemTestsElemFunctionParseValue SourceFormatJsonTestsElemTestsElemFunction = "parse_value"
const SourceFormatJsonTestsElemTestsElemFunctionRoundTrip SourceFormatJsonTestsElemTestsElemFunction = "round_trip"

var enumValues_SourceFormatJsonTestsElemTestsElemFunction = []interface{}{
	"parse",
	"parse_value",
	"filter",
	"compose",
	"expand_dotted",
	"build_hierarchy",
	"get_string",
	"get_int",
	"get_bool",
	"get_float",
	"get_list",
	"canonical_format",
	"load",
	"round_trip",
	"associativity",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SourceFormatJsonTestsElemTestsElemFunction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SourceFormatJsonTestsElemTestsElemFunction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SourceFormatJsonTestsElemTestsElemFunction, v)
	}
	*j = SourceFormatJsonTestsElemTestsElemFunction(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SourceFormatJsonTestsElemTestsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["expect"]; raw != nil && !ok {
		return fmt.Errorf("field expect in SourceFormatJsonTestsElemTestsElem: required")
	}
	if _, ok := raw["function"]; raw != nil && !ok {
		return fmt.Errorf("field function in SourceFormatJsonTestsElemTestsElem: required")
	}
	type Plain SourceFormatJsonTestsElemTestsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["error"]; !ok || v == nil {
		plain.Error = false
	}
	*j = SourceFormatJsonTestsElemTestsElem(plain)
	return nil
}

type SourceFormatJsonTestsElemVariantsElem string

const SourceFormatJsonTestsElemVariantsElemProposedBehavior SourceFormatJsonTestsElemVariantsElem = "proposed_behavior"
const SourceFormatJsonTestsElemVariantsElemReferenceCompliant SourceFormatJsonTestsElemVariantsElem = "reference_compliant"

var enumValues_SourceFormatJsonTestsElemVariantsElem = []interface{}{
	"proposed_behavior",
	"reference_compliant",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SourceFormatJsonTestsElemVariantsElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SourceFormatJsonTestsElemVariantsElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SourceFormatJsonTestsElemVariantsElem, v)
	}
	*j = SourceFormatJsonTestsElemVariantsElem(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SourceFormatJsonTestsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["input"]; raw != nil && !ok {
		return fmt.Errorf("field input in SourceFormatJsonTestsElem: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in SourceFormatJsonTestsElem: required")
	}
	if _, ok := raw["tests"]; raw != nil && !ok {
		return fmt.Errorf("field tests in SourceFormatJsonTestsElem: required")
	}
	type Plain SourceFormatJsonTestsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Tests != nil && len(plain.Tests) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "tests", 1)
	}
	*j = SourceFormatJsonTestsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SourceFormatJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["tests"]; raw != nil && !ok {
		return fmt.Errorf("field tests in SourceFormatJson: required")
	}
	type Plain SourceFormatJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Tests != nil && len(plain.Tests) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "tests", 1)
	}
	*j = SourceFormatJson(plain)
	return nil
}
